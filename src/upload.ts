import * as core from '@actions/core';
import * as artifact from '@actions/artifact';
import { promises as fsp } from 'fs';
import * as path from 'path';
import { IActionInputs } from './types';
import * as constants from './constants';

/**
 * If enabled, uploads all report files generated by the scanner as an artifact.
 * 
 * @param {IActionInputs} params 
 */
export async function generate( params: IActionInputs ): Promise<void> {
    core.startGroup( 'ðŸ“¦ Artifact Upload' );

    if ( params.upload_artifact ) {
        const filePaths = await getFilePaths();

        if ( filePaths.length > 0 ) {
            await upload( params, filePaths );
        } else {
            core.warning( 'No generated report files found to upload; skipping.' );
        }
    } else {
        core.info( 'Not enabled; skipping.' );
    }

    core.endGroup();
}

/**
 * Uploads an artifact containing the provided collection of absolute-pathed
 * report files.
 * 
 * @param {IActionInputs} params 
 * @param {string[]} filePaths 
 */
async function upload( params: IActionInputs, filePaths: string[] ): Promise<void> {
    try {
        core.info( `Preparing artifact "${params.artifact_name}" containing ${filePaths.length} generated reports.` );

        const client = artifact.create();
        const options: artifact.UploadOptions = {
            continueOnError: true,
            retentionDays: params.artifact_retention_days
        };

        const response = await client.uploadArtifact(
            params.artifact_name,
            filePaths,
            'reports',
            options
        );

        if ( response.failedItems.length > 0 ) {
            core.warning( `"${params.artifact_name}" failed to upload ${response.failedItems.length} items.` );
        } else {
            core.info( `Artifact "${params.artifact_name}" upload successful.` );
        }
    } catch ( err: any ) {
        core.warning( err.message );
    }
}

/**
 * Gets a list of fully-qualified file paths of reports generated by the scanner.
 * 
 * @returns {Promise<string[]>}
 */
async function getFilePaths(): Promise<string[]> {
    let filePaths: string[] = [];

    try {
        const generatedFiles = await fsp.readdir( constants.SCAN_OUTPUT_PATH );
        if ( generatedFiles.length > 0 )
            filePaths = generatedFiles
                .filter( filename => filename.indexOf( constants.REPORT_FILENAME_PREFIX ) !== -1 )
                .map( filename => path.join( constants.SCAN_OUTPUT_PATH, filename ));
    } catch { }

    return filePaths;
}